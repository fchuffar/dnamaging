---
title: "Code Hannum 2013"
---
title: "Model"
author: "Fabien Jossaud, Florent Chuffart"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
---

```{r echo=FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment = "#>", fig.width=9, fig.height=6, eval=TRUE, echo=TRUE, results="verbatim")
source("common.R")
```

```{r params}
source("params_default.R")
```

# We need to execute 03_preproc to have our df preprocess. 

```{r building_indexes}
idx_samples = rownames(df)
markers_start = grep("cg",colnames(df))[1]
idx_clinicals = colnames(df)[1:(markers_start-1)]
idx_cpg = colnames(df)[markers_start:ncol(df)]
```

```{r train/test}
Ntrain = floor(nrow(df)/2)
set.seed(1)
idx_train = sample(rownames(df),Ntrain)
idx_test = setdiff(rownames(df),idx_train)
```

# Model 

```{r prepare model}

Xtrain = df[idx_train,idx_cpg]
Ytrain = df[idx_train,y_key]

Xtest = df[idx_test,idx_cpg]
Ytest = df[idx_test,y_key]

``` 

```{r glmnet model}

Xtrain = data.matrix(Xtrain)
Xtest = data.matrix(Xtest)

## Cross validation for best lambda and alpha

alphas = seq(0,1,0.5)

stat = lapply(alphas,function(alpha){ 
  
  modelcv = glmnet::cv.glmnet(Xtrain,Ytrain, alpha = alpha, type.measure = "mse")
  lambdamin = modelcv$lambda.min
  cvrecap = data.frame(lambda = modelcv$lambda, RMSE = sqrt(modelcv$cvm), nbprobes = modelcv$nzero)
  ret = list(
    cvrecap = cvrecap, 
    lambdamin = lambdamin,
    # model = modelcv,
    alpha = alpha
  )
  return(ret)
  
  })

## Compute graph params 

lambda.lim = c()
RMSE.lim = c()
nbprobes.lim = c()
for (i in (1:length(stat))){
	lambda.lim = c(lambda.lim, min(stat[[i]]$cvrecap$lambda), max(stat[[i]]$cvrecap$lambda))
	RMSE.lim = c(RMSE.lim, min(stat[[i]]$cvrecap$RMSE), max(stat[[i]]$cvrecap$RMSE))
	nbprobes.lim = c(nbprobes.lim, min(stat[[i]]$cvrecap$nbprobes[stat[[i]]$cvrecap$nbprobes > 0]), max(stat[[i]]$cvrecap$nbprobes))
}
lambda.lim = c(log(min(lambda.lim))-0.5,log(max(lambda.lim))+0.5)
RMSE.lim = c(floor(min(RMSE.lim)),ceiling(max(RMSE.lim)))
nbprobes.lim = log(c(min(nbprobes.lim),max(nbprobes.lim)))
col = RColorBrewer::brewer.pal(n= length(stat), name = "Set1")

## Plot

layout(matrix(1:2,1),respect = TRUE)

plot(0,0,col = 0, xlab="log(lambda)", ylab="RMSE", xlim = lambda.lim, ylim = RMSE.lim, main = "RMSE depending on alphas and lambdas")
lapply(stat, function(it) { 
  cvrecap = it$cvrecap
  points(log(cvrecap$lambda),cvrecap$RMSE)
  abline(v = log(it$lambdamin))
  })
#legend(x="topleft", legend=alphas, col=col, title="Alphas")

plot(0,0,col = 0, xlab="log(lambda)", ylab="log(nbprobes)", xlim=lambda.lim, ylim=nbprobes.lim, main="nbprobes depending on alphas and lambdas" )
lapply(stat, function(it) { 
  cvrecap = it$cvrecap
  points(log(cvrecap$lambda),log(cvrecap$nbprobes))
  abline(v = log(it$lambdamin))
  })
#legend(x="topleft", legend=alphas, col=col, title="Alphas")

## Plotting alpha and lambda.min predictions 

layout(matrix(1:2,1), respect=TRUE)
RMSE_pred = lapply(stat, function(it) {
  
  model = glmnet::glmnet(Xtrain,Ytrain, alpha = it$alpha, lambda = it$lambdamin, standardize = TRUE) 
                         
  predTr = predict(model,Xtrain)
  RMSETr = signif(sqrt(mean((Ytrain - predTr)^2, na.rm = TRUE)),3)
  plot(predTr, Ytrain, xlab="Methylomic Age", ylab="Chronological Age", main = paste0("Pred Train set alpha = ",it$alpha,", RMSE = ", RMSETr))

  predTe = predict(model,Xtest)
  RMSETe = signif(sqrt(mean((Ytest - predTe)^2, na.rm = TRUE)),3)
  plot(predTe, Ytest, xlab="Methylomic Age", ylab="Chronological Age", main = paste0("Pred Test set alpha = ",it$alpha,", RMSE = ", RMSETe))  
  
  ret = list(
  	alpha = it$alpha,
  	lambda = it$lambdamin,
  	predTr = predTr,
  	predTe = predTe,
  	RMSETr = RMSETr,
  	RMSETe = RMSETe
  )
  return(ret)
})
  
```







# Session Information

```{r, results="verbatim"}
sessionInfo()
```
